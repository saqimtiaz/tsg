<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">
<title>Fast Pours</title>
<style>
html, body { margin:0; padding:0; height:100%; background:#111; color:#fff; font-family: system-ui,sans-serif; overflow:hidden; }
#app { display:flex; flex-direction:column; height:100%; }
#canvasWrap { flex:1; display:flex; align-items:center; justify-content:center; }
canvas { display:block; background:#000; touch-action:none; }
#controls { padding:10px; text-align:center; }
button { font-size:16px; padding:8px 16px; }
</style>
</head>
<body>
<div id="app">
	<div id="canvasWrap">
		<canvas id="canvas"></canvas>
	</div>
	<div id="controls">
		<button id="exportBtn">Export PNG</button>
	</div>
</div>
<script>
/* ================= CONFIG ================= */
const CANVAS_WIDTH = 1440;
const CANVAS_HEIGHT = 1920;
const PADDING = 80;        // left, right, bottom
const TOP_PADDING = 133;   // top
const HOLD_DELAY = 400;
const HOLD_MOVE_THRESHOLD = 10;
const SNAP_THRESHOLD = 8;
const WHEEL_ZOOM_STEP = 0.05;
const KEY_NUDGE = 1;
const KEY_NUDGE_FAST = 5;

/* ================= DERIVED BOX ================= */
const BOX = {
  x: PADDING,
  y: TOP_PADDING,
  width: CANVAS_WIDTH - 2*PADDING,
  height: CANVAS_HEIGHT - (TOP_PADDING + PADDING)
};

/* ================= STATE ================= */
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";

let templateImg=null, templateData=null, photoImg=null, photoFilename=null;
let scale=1, offsetX=0, offsetY=0;
let isDragging=false, dragStart={x:0,y:0}, holdTimer=null;
let lastTapTime=0;
let pointers=new Map();
let pinchStartDistance=null, scaleStart=1, offsetStartX=0, offsetStartY=0;
let pinchMidX=0, pinchMidY=0;
let pinching=false;
let launchedFromShare = false;


/* ================= RESIZE ================= */
function resizeCanvas(){
	const wrap = document.getElementById("canvasWrap");
	const w = wrap.clientWidth;
	const h = wrap.clientHeight;

	// Keep canvas aspect ratio (1440 / 1920 = 0.75)
	const aspect = CANVAS_WIDTH / CANVAS_HEIGHT;
	let drawW = w;
	let drawH = w / aspect;

	if(drawH > h){ 
		drawH = h;
		drawW = h * aspect;
	}

	canvas.style.width = drawW + "px";
	canvas.style.height = drawH + "px";

	// Always keep the internal resolution at full output size
	canvas.width = CANVAS_WIDTH;
	canvas.height = CANVAS_HEIGHT;

	// Improve image quality when scaling
	ctx.imageSmoothingEnabled = true;
	ctx.imageSmoothingQuality = "high";

	draw();
}
window.addEventListener("resize", resizeCanvas);

/* ================= DRAW ================= */
function draw(){
	ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);

	// Draw template if loaded
	if(templateImg) ctx.drawImage(templateImg, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

	if(photoImg){
		// Compute scaled image dimensions and position
		const imgW = photoImg.width * scale;
		const imgH = photoImg.height * scale;
		let x = BOX.x + offsetX;
		let y = BOX.y + offsetY;

		// Snap to edges only if image is larger than box in that dimension
		const snapX = imgW > BOX.width;
		const snapY = imgH > BOX.height;

		if(snapX){
			if(Math.abs(x - BOX.x) < SNAP_THRESHOLD) x = BOX.x;
			if(Math.abs((x + imgW) - (BOX.x + BOX.width)) < SNAP_THRESHOLD) x = BOX.x + BOX.width - imgW;
		}
		if(snapY){
			if(Math.abs(y - BOX.y) < SNAP_THRESHOLD) y = BOX.y;
			if(Math.abs((y + imgH) - (BOX.y + BOX.height)) < SNAP_THRESHOLD) y = BOX.y + BOX.height - imgH;
		}

		// Update offsets after snapping
		offsetX = x - BOX.x;
		offsetY = y - BOX.y;

		// Draw photo clipped to BOX
		ctx.save();
		ctx.beginPath();
		ctx.rect(BOX.x, BOX.y, BOX.width, BOX.height);
		ctx.clip();
		ctx.drawImage(photoImg, x, y, imgW, imgH);
		ctx.restore();

		// Check if photo fully covers the BOX, with epsilon to prevent floating point errors
		const EPS = 0.5;
		const fullyCoversBox = (x <= BOX.x + EPS) && (y <= BOX.y + EPS) &&
								((x + imgW) >= (BOX.x + BOX.width - EPS)) &&
								((y + imgH) >= (BOX.y + BOX.height - EPS));

		// Draw dotted outline if photo doesn't fully cover BOX
		if(!fullyCoversBox){
			ctx.save();
			ctx.strokeStyle = "white";
			ctx.setLineDash([4,4]);
			ctx.lineWidth = 2;
			ctx.strokeRect(BOX.x, BOX.y, BOX.width, BOX.height);
			ctx.restore();
		}
	} else {
		// No photo yet, draw outline
		ctx.save();
		ctx.strokeStyle = "white";
		ctx.setLineDash([4,4]);
		ctx.lineWidth = 2;
		ctx.strokeRect(BOX.x, BOX.y, BOX.width, BOX.height);
		ctx.restore();
	}
}




/* ================= HELPERS ================= */
function resetPhoto(){
	scale=Math.min(BOX.width/photoImg.width,BOX.height/photoImg.height);
	offsetX=(BOX.width-photoImg.width*scale)/2;
	offsetY=(BOX.height-photoImg.height*scale)/2;
}
function loadImage(file,cb){const img=new Image(); img.onload=()=>cb(img); img.src=URL.createObjectURL(file);}
function pickFile(cb){const input=document.createElement("input"); input.type="file"; input.accept="image/*"; input.onchange=()=>{if(input.files&&input.files[0]) loadImage(input.files[0],img=>cb(img,input.files[0].name));}; input.click();}
function imgToBase64(img){const tmp=document.createElement("canvas"); tmp.width=img.width; tmp.height=img.height; tmp.getContext("2d").drawImage(img,0,0); return tmp.toDataURL();}
function loadTemplateFromStorage(){const data=localStorage.getItem("templateData"); if(data){const img=new Image(); img.onload=()=>{templateImg=img; draw();}; img.src=data;}}

/* ================= FIRST-TAP PICKER FIX ================= */
function promptTemplateOrImage(cx,cy){
	if(launchedFromShare && photoImg) return false;
	// Ensure picker call happens after the tap is fully processed
	if(!templateImg){
		setTimeout(()=>pickFile((img,name)=>{
			templateImg = img;
			templateData = imgToBase64(img);
			localStorage.setItem("templateData",templateData);
			draw();
		}),0);
		return true;
	}
	if(!photoImg){
		setTimeout(()=>pickFile((img,name)=>{
			photoImg = img;
			photoFilename = name;
			resetPhoto();
			draw();
		}),0);
		return true;
	}
	return false;
}

/* ================= POINTER EVENTS ================= */
canvas.addEventListener("pointerdown", e=>{
	const rect=canvas.getBoundingClientRect();
	const cx=(e.clientX-rect.left)*(CANVAS_WIDTH/rect.width);
	const cy=(e.clientY-rect.top)*(CANVAS_HEIGHT/rect.height);
	const insideBox=cx>=BOX.x && cx<=BOX.x+BOX.width && cy>=BOX.y && cy<=BOX.y+BOX.height;

	// FIRST TAP HANDLING
	if(promptTemplateOrImage(cx,cy)) return;

	pointers.set(e.pointerId,{x:e.clientX,y:e.clientY,moved:false,totalDx:0,totalDy:0});

	if(pointers.size===1){
		isDragging=true; dragStart.x=e.clientX; dragStart.y=e.clientY;
		holdTimer=setTimeout(()=>{
			const p = pointers.get(e.pointerId);
			if(p && !p.moved && Math.hypot(p.totalDx,p.totalDy) < HOLD_MOVE_THRESHOLD){
				isDragging=false; pointers.clear();
				if(insideBox){
					pickFile((img,name)=>{photoImg=img; photoFilename=name; resetPhoto(); draw();});
				}else{
					pickFile((img,name)=>{templateImg=img; templateData=imgToBase64(img); localStorage.setItem("templateData",templateData); draw();});
				}
			}
		}, HOLD_DELAY);
	}else{ clearTimeout(holdTimer); isDragging=false; pinchStartDistance=null; pinching=false; }
});

canvas.addEventListener("pointermove", e=>{
	const p=pointers.get(e.pointerId); if(!p) return;
	const dx=e.clientX-p.x, dy=e.clientY-p.y;
	p.totalDx+=dx; p.totalDy+=dy;
	if(Math.hypot(dx,dy)>HOLD_MOVE_THRESHOLD){ p.moved=true; clearTimeout(holdTimer); }
	pointers.set(e.pointerId,{x:e.clientX,y:e.clientY,moved:p.moved,totalDx:p.totalDx,totalDy:p.totalDy});

	if(!photoImg) return;
	if(pointers.size===1 && isDragging){
		offsetX += dx*(CANVAS_WIDTH/canvas.clientWidth);
		offsetY += dy*(CANVAS_HEIGHT/canvas.clientHeight);
		draw();
	}
	if(pointers.size===2){
		const [p1,p2]=[...pointers.values()];
		const currentDistance=Math.hypot(p1.x-p2.x,p1.y-p2.y);
		if(!pinching){
			pinching=true; pinchStartDistance=currentDistance;
			scaleStart=scale; offsetStartX=offsetX; offsetStartY=offsetY;
			const rect=canvas.getBoundingClientRect();
			const midX=(p1.x+p2.x)/2, midY=(p1.y+p2.y)/2;
			pinchMidX=(midX-rect.left)*(CANVAS_WIDTH/rect.width);
			pinchMidY=(midY-rect.top)*(CANVAS_HEIGHT/rect.height);
		}
		const zoom=currentDistance/pinchStartDistance;
		scale = scaleStart*zoom;
		offsetX = pinchMidX-(pinchMidX-offsetStartX)*zoom;
		offsetY = pinchMidY-(pinchMidY-offsetStartY)*zoom;
		draw();
	}
});

canvas.addEventListener("pointerup", e=>{
	pointers.delete(e.pointerId);
	if(pointers.size<2){ pinchStartDistance=null; pinching=false; }
	isDragging=false; clearTimeout(holdTimer);

	const rect=canvas.getBoundingClientRect();
	const cx=(e.clientX-rect.left)*(CANVAS_WIDTH/rect.width);
	const cy=(e.clientY-rect.top)*(CANVAS_HEIGHT/rect.height);
	const insideBox=cx>=BOX.x && cx<=BOX.x+BOX.width && cy>=BOX.y && cy<=BOX.y+BOX.height;

	if(photoImg && insideBox && pointers.size===0 && !pinching){
		const now=Date.now();
		if(now-lastTapTime<300){ resetPhoto(); draw(); }
		lastTapTime=now;
	}
});

canvas.addEventListener("pointercancel",()=>{pointers.clear(); pinchStartDistance=null; pinching=false; isDragging=false; clearTimeout(holdTimer);});

/* ================= WHEEL & KEYS ================= */
canvas.addEventListener("wheel", e=>{if(!photoImg) return; e.preventDefault(); scale*=e.deltaY<0?(1+WHEEL_ZOOM_STEP):(1-WHEEL_ZOOM_STEP); draw();},{passive:false});
window.addEventListener("keydown", e=>{if(!photoImg) return; const step=e.shiftKey?KEY_NUDGE_FAST:KEY_NUDGE; if(e.key==="ArrowLeft") offsetX-=step; if(e.key==="ArrowRight") offsetX+=step; if(e.key==="ArrowUp") offsetY-=step; if(e.key==="ArrowDown") offsetY+=step; draw();});

/* ================= EXPORT ================= */
document.getElementById("exportBtn").onclick=()=>{
	const link=document.createElement("a");
	const now=new Date();
	const timestamp=now.toISOString().replace(/[:.]/g,"-");
	const prefix=photoFilename?photoFilename.replace(/\.[^/.]+$/,"")+"_":"";
	link.download=`${prefix}${timestamp}.png`;
	link.href=canvas.toDataURL("image/png");
	link.click();
};

/* ================= INIT ================= */
window.addEventListener("load",()=>{
	if("serviceWorker" in navigator){
		navigator.serviceWorker.register("/tsg/fastpours/sw.js");
	}

	loadTemplateFromStorage();
	resizeCanvas();
});
// Handle Android share-targets
if('launchQueue' in window){
	window.launchQueue.setConsumer(launchParams=>{
		if(!launchParams.files || launchParams.files.length===0) return;
		const fileHandle = launchParams.files[0];
		launchedFromShare = true;
		fileHandle.getFile().then(file=>{
			loadImage(file, img=>{
				photoImg = img;
				photoFilename = file.name;
				resetPhoto();
				draw();
			});
		});
	});
}
</script>
</body>
</html>
